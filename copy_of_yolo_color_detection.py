# -*- coding: utf-8 -*-
"""Copy of OG YOLO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13_E-Ogk9aY0WR_8dqtyxPFezIgfToaq5
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
from IPython.display import Image

uploaded = files.upload()

# Import the image

def convertImages2RGB(images):
  # images is a list of images.  This function takes in a list of images and converts it to the correct color scheme to be displayed through the plt.imshow() function
  rgb_images = []
  for img in images:
    # convert bgr to rgb
    rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    print("Plotting RGB values")
    plt.imshow(rgb, cmap = plt.cm.Spectral)
    rgb_images.append(img)
  return rgb_images

img = cv2.imread('dark_skin_eczema.png') #We created a variable named img and set it equal to the cv2.imread object
images = []
images.append(img)

convertImages2RGB(images)
#img_color= cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # We have to convert it because imread used BGR the reverse color space and the plot function used RGB color spaces
#plt.imshow(img_color)  #This uses the matplotlib library to plot/display the img variable

fig, axs = plt.subplots(nrows = 1, ncols = 3, figsize = (20, 20))
for i in range(0, 3):
    ax = axs[i]
    ax.imshow(img[:, :, i], cmap = 'gray')

plt.show()

# Transform the image into HSV and HLS models (Hue, Saturation, Lightness, and Value).
#Transforming the image is important in computer vision because this process along with masking makes it easier for it to analyze the image
scleroderma_img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
scleroderma_img_hls = cv2.cvtColor(img, cv2.COLOR_BGR2HLS)

# Plot the converted images
fig, (ax1, ax2) = plt.subplots(nrows = 1, ncols = 2, figsize = (20, 20))
ax1.imshow(scleroderma_img_hsv)
ax2.imshow(scleroderma_img_hls)
plt.show()

lower_bound = np.array([72,41,30])
upper_bound = np.array([94,68,46])
mask = cv2.inRange(scleroderma_img_hsv, lower_bound, upper_bound) #inRange() function returns a binary mask of the frame where the brown color is present.

#define kernel size
kernel = np.ones((7,7),np.uint8)

# Remove unnecessary noise from mask

mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel) #cv2.MORPH_CLOSE removes unnecessary black noises from the white region.
mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel) #cv2.MORPH_OPE removes unnecessary black noises from the white region.

avg_color_per_row = np.average(img, axis=0)
avg_color = np.average(avg_color_per_row, axis=0)
print(avg_color)
img_color= cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.imshow(img_color)
#This is supposed to be the average color



avg_color_per_row = np.average(img, axis=0)
avg_color = np.average(avg_color_per_row, axis=0)
print(avg_color) #This gives us the values of the "average color" of the photo, which we'll use to highlight the lesions

#get height and width of image
hh, ww = img.shape[:2]
print(hh, ww)

# get pixel at x=0,y=0
px1 = img[0:1, 0:1]

# get pixel at center of image
hh2 = hh//2
ww2 = ww//2
px2 = img[hh2:hh2+1, ww2:ww2+1]

print(px1)
print(px2)

img_array = np.array(img_color) #print img RGB Values into an array
print(img_array.shape) #the shape of img_array also matches with resolution of img_color

from PIL import Image, ImageDraw, ImageFont

pixel = img #sets pixel variable to images
mutated_image = []
for row in img_array:
    mutated_row = []
    for rgb_array in row:
        mutated_rgb = []
        if rgb_array[0] > 70 and rgb_array[0] < 85 and rgb_array[1] > 50 and rgb_array[1] < 100 and rgb_array[2] > 30 and rgb_array[2] < 100:
            mutated_rgb = (0,255,0)
        else:
            mutated_rgb = rgb_array
        mutated_row.append(mutated_rgb)
    mutated_image.append(mutated_row)
plt.imshow(mutated_image, interpolation='none')
plt.show()

img_pixel = pixel[k,l]
pixel_str = str(img_pixel)
for k in range(img.size[0]):
    for l in range(img.size[1]):
        img_pixel = pixel[k,l]
        if img_pixel[0] < 98 and img_pixel[1] < 80 and img_pixel[2] > 35: #This determines the "brown spots" of the area
            pixel[k,l] = (0,180,0)
plt.imshow(img)